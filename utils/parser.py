"""
MT5 Strategy Tester Report Parser
Parses HTML reports and CSV files generated by MetaTrader 5 Strategy Tester
"""

import pandas as pd
from bs4 import BeautifulSoup
import re
from datetime import datetime
import numpy as np
import io

class MT5ReportParser:
    def __init__(self):
        self.trades_data = None
        self.summary_data = None
        
    def parse_html_report(self, file_path):
        """Parse MT5 HTML report and extract trade data"""
        try:
            # Try different encodings
            encodings = ['utf-8', 'utf-16', 'latin-1', 'cp1252', 'iso-8859-1']
            content = None
            
            for encoding in encodings:
                try:
                    with open(file_path, 'r', encoding=encoding) as file:
                        content = file.read()
                    break
                except UnicodeDecodeError:
                    continue
            
            if content is None:
                raise Exception("Could not decode file with any supported encoding")
            
            soup = BeautifulSoup(content, 'html.parser')
            
            # Extract trades table
            trades_df = self._extract_trades_table(soup)
            
            # Extract summary statistics
            summary_dict = self._extract_summary_stats(soup)
            
            return trades_df, summary_dict
            
        except Exception as e:
            raise Exception(f"Error parsing MT5 report: {str(e)}")
    
    def _extract_trades_table(self, soup):
        """Extract individual trades from the report"""
        trades = []
        
        # Look for the "Deals" section specifically
        deals_found = False
        all_rows = soup.find_all('tr')
        
        for i, row in enumerate(all_rows):
            # Check if this row contains "Deals" header
            if row.find('th') and 'deals' in row.get_text().lower():
                deals_found = True
                continue
            
            # If we found deals section, look for the header row
            if deals_found and row.get('bgcolor') == '#E5F0FC':
                # This is the header row, start processing data rows
                header_cells = row.find_all('td')
                if len(header_cells) >= 10:  # Expected number of columns
                    # Process subsequent data rows
                    for j in range(i + 1, len(all_rows)):
                        data_row = all_rows[j]
                        
                        # Stop if we hit another section
                        if data_row.find('th') or data_row.get('colspan'):
                            break
                            
                        cells = data_row.find_all('td')
                        if len(cells) >= 10:  # Minimum expected columns
                            trade_data = self._parse_mt5_deal_row(cells)
                            if trade_data:
                                trades.append(trade_data)
                break
        
        if trades:
            df = pd.DataFrame(trades)
            df = self._clean_trades_dataframe(df)
            return df
        else:
            return pd.DataFrame()
    
    def _parse_trade_row(self, cells):
        """Parse individual trade row"""
        try:
            # Common MT5 report structure
            trade = {}
            
            # Extract time (usually first column)
            time_text = cells[0].get_text().strip()
            trade['time'] = self._parse_datetime(time_text)
            
            # Extract type (buy/sell)
            if len(cells) > 1:
                trade['type'] = cells[1].get_text().strip()
            
            # Extract profit (look for numeric values with +/- signs)
            for cell in cells:
                text = cell.get_text().strip()
                if self._is_profit_value(text):
                    trade['profit'] = self._parse_profit(text)
                    break
            
            # Extract volume if available
            for cell in cells:
                text = cell.get_text().strip()
                if self._is_volume_value(text):
                    trade['volume'] = float(text)
                    break
            
            return trade if 'profit' in trade else None
            
        except Exception:
            return None
    
    def _parse_mt5_deal_row(self, cells):
        """Parse MT5 deal row with specific column structure"""
        try:
            # MT5 Deal structure: Time, Deal, Symbol, Type, Direction, Volume, Price, Order, Commission, Swap, Profit, Balance, Comment
            if len(cells) < 11:
                return None
            
            trade = {}
            
            # Extract time (column 0)
            time_text = cells[0].get_text().strip()
            trade['time'] = self._parse_datetime(time_text)
            
            if not trade['time']:
                return None
            
            # Extract type and direction (columns 3 and 4)
            trade_type = cells[3].get_text().strip().lower()
            direction = cells[4].get_text().strip().lower()
            
            # Only process actual trades (not balance entries)
            if trade_type == 'balance':
                return None
            
            # Combine type and direction for trade type
            if direction == 'in':
                trade['type'] = f"{trade_type}_open"
            elif direction == 'out':
                trade['type'] = f"{trade_type}_close"
            else:
                trade['type'] = trade_type
            
            # Extract volume (column 5)
            volume_text = cells[5].get_text().strip()
            if volume_text:
                try:
                    trade['volume'] = float(volume_text)
                except:
                    trade['volume'] = 0.0
            
            # Extract profit (column 10)
            profit_text = cells[10].get_text().strip()
            trade['profit'] = self._parse_profit(profit_text)
            
            # Only return trades with actual profit/loss (not 0.00 opening trades)
            if trade['profit'] != 0.0:
                return trade
            
            return None
            
        except Exception as e:
            return None
    
    def _parse_datetime(self, time_str):
        """Parse datetime from various MT5 formats"""
        time_str = time_str.strip()
        
        # Common MT5 datetime formats
        formats = [
            '%Y.%m.%d %H:%M:%S',
            '%Y.%m.%d %H:%M',
            '%d.%m.%Y %H:%M:%S',
            '%d.%m.%Y %H:%M',
            '%Y-%m-%d %H:%M:%S',
            '%Y/%m/%d %H:%M:%S'
        ]
        
        for fmt in formats:
            try:
                return datetime.strptime(time_str, fmt)
            except ValueError:
                continue
        
        return None
    
    def _is_profit_value(self, text):
        """Check if text contains profit/loss value"""
        # Look for numbers with + or - signs, or decimal numbers
        pattern = r'^[+-]?\d+\.?\d*$'
        return bool(re.match(pattern, text.replace(',', '').replace(' ', '')))
    
    def _is_volume_value(self, text):
        """Check if text contains volume value"""
        try:
            val = float(text)
            return 0 < val < 1000  # Reasonable volume range
        except:
            return False
    
    def _parse_profit(self, profit_str):
        """Parse profit value from string"""
        try:
            # Handle different formats like "999 999 999.00", "-20.83", etc.
            cleaned = profit_str.replace(' ', '').replace(',', '')
            
            # Remove currency symbols but keep +/- signs and decimals
            cleaned = re.sub(r'[^\d.+-]', '', cleaned)
            
            if cleaned and cleaned not in ['+', '-', '.']:
                return float(cleaned)
            return 0.0
        except:
            return 0.0
    
    def _clean_trades_dataframe(self, df):
        """Clean and prepare trades dataframe"""
        if df.empty:
            return df
        
        # Ensure required columns exist
        required_cols = ['time', 'profit']
        for col in required_cols:
            if col not in df.columns:
                df[col] = None
        
        # Remove rows with invalid data
        df = df.dropna(subset=['time', 'profit'])
        
        # Convert time to datetime
        df['time'] = pd.to_datetime(df['time'])
        
        # Sort by time
        df = df.sort_values('time').reset_index(drop=True)
        
        return df
    
    def _extract_summary_stats(self, soup):
        """Extract comprehensive MT5 summary statistics from report"""
        summary = {}
        
        # Get all text content
        text = soup.get_text()
        
        # Comprehensive MT5 statistics patterns
        patterns = {
            # Basic Info
            'initial_deposit': r'Initial Deposit\s*:?\s*([\d\s,]+\.?\d*)',
            'leverage': r'Leverage\s*:?\s*1:(\d+)',
            'currency': r'Currency\s*:?\s*([A-Z]{3})',
            
            # History Quality
            'history_quality': r'History Quality\s*:?\s*([\d%\s\w]+)',
            'bars': r'Bars\s*:?\s*([\d\s,]+)',
            'ticks': r'Ticks\s*:?\s*([\d\s,]+)',
            'symbols': r'Symbols\s*:?\s*(\d+)',
            
            # Profit/Loss Metrics
            'total_net_profit': r'Total Net Profit\s*:?\s*([+-]?[\d\s,]+\.?\d*)',
            'gross_profit': r'Gross Profit\s*:?\s*([+-]?[\d\s,]+\.?\d*)',
            'gross_loss': r'Gross Loss\s*:?\s*([+-]?[\d\s,]+\.?\d*)',
            
            # Drawdown Metrics - REMOVED (we don't have tick data for real drawdown)
            
            # Performance Ratios
            'profit_factor': r'Profit Factor\s*:?\s*([+-]?[\d.]+)',
            'recovery_factor': r'Recovery Factor\s*:?\s*([+-]?[\d.]+)',
            'expected_payoff': r'Expected Payoff\s*:?\s*([+-]?[\d.]+)',
            'sharpe_ratio': r'Sharpe Ratio\s*:?\s*([+-]?[\d.]+)',
            'ahpr': r'AHPR\s*:?\s*([+-]?[\d.]+)',
            'ghpr': r'GHPR\s*:?\s*([+-]?[\d.]+)',
            
            # Statistical Measures
            'z_score': r'Z-Score\s*:?\s*([+-]?[\d.]+)',
            'lr_correlation': r'LR Correlation\s*:?\s*([+-]?[\d.]+)',
            'lr_standard_error': r'LR Standard Error\s*:?\s*([+-]?[\d.]+)',
            'margin_level': r'Margin Level\s*:?\s*([\d.]+%)',
            
            # Trade Statistics
            'total_trades': r'Total Trades\s*:?\s*([\d\s,]+)',
            'total_deals': r'Total Deals\s*:?\s*([\d\s,]+)',
            'short_trades': r'Short Trades.*?(\d+)',
            'long_trades': r'Long Trades.*?(\d+)',
            'profit_trades': r'Profit Trades.*?(\d+)',
            'loss_trades': r'Loss Trades.*?(\d+)',
            'short_trades_won_pct': r'Short Trades.*?\(([0-9.]+)%\)',
            'long_trades_won_pct': r'Long Trades.*?\(([0-9.]+)%\)',
            'profit_trades_pct': r'Profit Trades.*?\(([0-9.]+)%\)',
            'loss_trades_pct': r'Loss Trades.*?\(([0-9.]+)%\)',
            
            # Individual Trade Metrics
            'largest_profit_trade': r'Largest profit trade\s*:?\s*([+-]?[\d.]+)',
            'largest_loss_trade': r'Largest loss trade\s*:?\s*([+-]?[\d.]+)',
            'average_profit_trade': r'Average profit trade\s*:?\s*([+-]?[\d.]+)',
            'average_loss_trade': r'Average loss trade\s*:?\s*([+-]?[\d.]+)',
            
            # Consecutive Trades
            'max_consecutive_wins': r'Maximum consecutive wins.*?(\d+)',
            'max_consecutive_losses': r'Maximum consecutive losses.*?(\d+)',
            'max_consecutive_wins_profit': r'Maximum consecutive wins.*?\$?\s*\(([+-]?[\d.]+)\)',
            'max_consecutive_losses_loss': r'Maximum consecutive losses.*?\$?\s*\(([+-]?[\d.]+)\)',
            'maximal_consecutive_profit': r'Maximal consecutive profit.*?([+-]?[\d.]+)',
            'maximal_consecutive_loss': r'Maximal consecutive loss.*?([+-]?[\d.]+)',
            'average_consecutive_wins': r'Average consecutive wins\s*:?\s*(\d+)',
            'average_consecutive_losses': r'Average consecutive losses\s*:?\s*(\d+)',
            
            # Correlation Metrics
            'correlation_profits_mfe': r'Correlation.*?Profits.*?MFE.*?([+-]?[\d.]+)',
            'correlation_profits_mae': r'Correlation.*?Profits.*?MAE.*?([+-]?[\d.]+)',
            'correlation_mfe_mae': r'Correlation.*?MFE.*?MAE.*?([+-]?[\d.]+)',
            
            # Position Holding Times
            'minimal_position_holding_time': r'Minimal position holding time\s*:?\s*([\d:]+)',
            'maximal_position_holding_time': r'Maximal position holding time\s*:?\s*([\d:]+)',
            'average_position_holding_time': r'Average position holding time\s*:?\s*([\d:]+)',
            
            # OnTester Result
            'ontester_result': r'OnTester result\s*:?\s*(\d+)'
        }
        
        # Extract all metrics
        for key, pattern in patterns.items():
            match = re.search(pattern, text, re.IGNORECASE | re.DOTALL)
            if match:
                value = match.group(1).strip()
                
                # Clean and convert values
                if key in ['initial_deposit', 'bars', 'ticks', 'total_trades', 'total_deals', 
                          'short_trades', 'long_trades', 'profit_trades', 'loss_trades']:
                    # Remove spaces and commas from large numbers
                    cleaned_value = re.sub(r'[\s,]', '', value)
                    try:
                        summary[key] = int(cleaned_value)
                    except:
                        summary[key] = value
                        
                elif key in ['total_net_profit', 'gross_profit', 'gross_loss',
                           'profit_factor', 'recovery_factor', 'expected_payoff',
                           'sharpe_ratio', 'ahpr', 'ghpr', 'z_score', 'lr_correlation',
                           'lr_standard_error', 'largest_profit_trade', 'largest_loss_trade',
                           'average_profit_trade', 'average_loss_trade',
                           'maximal_consecutive_profit', 'maximal_consecutive_loss']:
                    # Clean numeric values
                    cleaned_value = re.sub(r'[\s,]', '', value)
                    try:
                        summary[key] = float(cleaned_value)
                    except:
                        summary[key] = value
                        
                elif key in ['short_trades_won_pct', 'long_trades_won_pct', 
                           'profit_trades_pct', 'loss_trades_pct']:
                    try:
                        summary[key] = float(value)
                    except:
                        summary[key] = value
                        
                elif key in ['max_consecutive_wins', 'max_consecutive_losses',
                           'average_consecutive_wins', 'average_consecutive_losses',
                           'leverage', 'symbols', 'ontester_result']:
                    try:
                        summary[key] = int(value)
                    except:
                        summary[key] = value
                        
                else:
                    # Keep as string for other values
                    summary[key] = value
        
        return summary
    
    def parse_csv_report(self, file_content):
        """Parse CSV file with trade data"""
        try:
            # Try to read CSV with different separators
            separators = [',', ';', '\t']
            df = None
            
            for sep in separators:
                try:
                    # Reset file pointer
                    file_content.seek(0)
                    df = pd.read_csv(file_content, sep=sep)
                    
                    # Check if we got reasonable columns
                    if len(df.columns) > 1 and len(df) > 0:
                        break
                except Exception as e:
                    continue
            
            if df is None or df.empty:
                raise Exception("Could not parse CSV file")
            
            # Try to identify columns automatically
            trades_df = self._map_csv_columns(df)
            
            # Generate basic summary from CSV data
            summary_dict = self._generate_csv_summary(trades_df)
            
            return trades_df, summary_dict
            
        except Exception as e:
            raise Exception(f"Error parsing CSV file: {str(e)}")
    
    def _map_csv_columns(self, df):
        """Automatically map CSV columns to standard format"""
        # Common column name mappings
        column_mappings = {
            'time': ['time', 'date', 'datetime', 'timestamp', 'open_time', 'close_time'],
            'profit': ['profit', 'pnl', 'p&l', 'net_profit', 'result', 'gain_loss'],
            'symbol': ['symbol', 'instrument', 'pair', 'currency_pair'],
            'type': ['type', 'side', 'direction', 'buy_sell', 'order_type'],
            'volume': ['volume', 'size', 'lot_size', 'quantity', 'amount'],
            'price': ['price', 'open_price', 'close_price', 'entry_price', 'exit_price']
        }
        
        # Create mapped dataframe
        mapped_df = pd.DataFrame()
        
        # Map columns by name similarity
        for target_col, possible_names in column_mappings.items():
            found_col = None
            
            # Look for exact matches first
            for col in df.columns:
                if col.lower().strip() in [name.lower() for name in possible_names]:
                    found_col = col
                    break
            
            # If no exact match, look for partial matches
            if found_col is None:
                for col in df.columns:
                    for name in possible_names:
                        if name.lower() in col.lower() or col.lower() in name.lower():
                            found_col = col
                            break
                    if found_col:
                        break
            
            # Add column if found
            if found_col is not None:
                mapped_df[target_col] = df[found_col]
        
        # If no time column found, try to use index or create sequential times
        if 'time' not in mapped_df.columns:
            if len(df) > 0:
                # Create sequential timestamps
                base_time = datetime.now()
                mapped_df['time'] = pd.date_range(
                    start=base_time, 
                    periods=len(df), 
                    freq='h'
                )
        
        # If no profit column found, look for numeric columns
        if 'profit' not in mapped_df.columns:
            numeric_cols = df.select_dtypes(include=[np.number]).columns
            if len(numeric_cols) > 0:
                # Use the first numeric column as profit
                mapped_df['profit'] = df[numeric_cols[0]]
        
        # Ensure we have minimum required data
        if 'profit' not in mapped_df.columns:
            raise Exception("Could not identify profit/PnL column in CSV")
        
        # Clean and validate the dataframe
        mapped_df = self._clean_trades_dataframe(mapped_df)
        
        return mapped_df
    
    def _generate_csv_summary(self, trades_df):
        """Generate summary statistics from CSV trade data"""
        if trades_df.empty:
            return {}
        
        # Calculate basic statistics
        total_trades = len(trades_df)
        profitable_trades = len(trades_df[trades_df['profit'] > 0])
        loss_trades = len(trades_df[trades_df['profit'] < 0])
        
        gross_profit = trades_df[trades_df['profit'] > 0]['profit'].sum()
        gross_loss = abs(trades_df[trades_df['profit'] < 0]['profit'].sum())
        total_net_profit = trades_df['profit'].sum()
        
        # Generate summary dictionary similar to MT5 format
        summary = {
            'Total trades': total_trades,
            'Profit trades (% of total)': f"{profitable_trades} ({profitable_trades/total_trades*100:.2f}%)" if total_trades > 0 else "0 (0.00%)",
            'Loss trades (% of total)': f"{loss_trades} ({loss_trades/total_trades*100:.2f}%)" if total_trades > 0 else "0 (0.00%)",
            'Total Net Profit': f"{total_net_profit:.2f}",
            'Gross Profit': f"{gross_profit:.2f}",
            'Gross Loss': f"-{gross_loss:.2f}",
            'Profit Factor': f"{gross_profit/gross_loss:.2f}" if gross_loss > 0 else "N/A",
            'Largest profit trade': f"{trades_df['profit'].max():.2f}" if not trades_df.empty else "0.00",
            'Largest loss trade': f"{trades_df['profit'].min():.2f}" if not trades_df.empty else "0.00",
            'Average profit trade': f"{trades_df[trades_df['profit'] > 0]['profit'].mean():.2f}" if profitable_trades > 0 else "0.00",
            'Average loss trade': f"{trades_df[trades_df['profit'] < 0]['profit'].mean():.2f}" if loss_trades > 0 else "0.00",
            'Maximum consecutive wins (profit in money)': "N/A (CSV data)",
            'Maximum consecutive losses (loss in money)': "N/A (CSV data)",
            'Maximal consecutive profit (count of wins)': "N/A (CSV data)",
            'Maximal consecutive loss (count of losses)': "N/A (CSV data)",
            'Average consecutive wins': "N/A (CSV data)",
            'Average consecutive losses': "N/A (CSV data)"
        }
        
        return summary

def parse_uploaded_report(uploaded_file):
    """Helper function to parse uploaded Streamlit file (HTML or CSV)"""
    parser = MT5ReportParser()
    
    # Determine file type from name
    file_name = uploaded_file.name.lower()
    is_csv = file_name.endswith('.csv')
    is_html = file_name.endswith(('.html', '.htm'))
    
    try:
        if is_csv:
            # Parse CSV file
            file_content = io.StringIO(uploaded_file.getvalue().decode('utf-8'))
            trades_df, summary_dict = parser.parse_csv_report(file_content)
            
        elif is_html:
            # Parse HTML file (existing functionality)
            temp_file = "temp_report.html"
            try:
                with open(temp_file, "wb") as f:
                    f.write(uploaded_file.getbuffer())
                
                trades_df, summary_dict = parser.parse_html_report(temp_file)
                
            finally:
                # Clean up temp file
                import os
                if os.path.exists(temp_file):
                    os.remove(temp_file)
        else:
            raise Exception("Unsupported file format. Please upload HTML or CSV files.")
        
        # Ensure the DataFrame has required columns
        if not trades_df.empty and 'time' in trades_df.columns:
            # Make sure time is datetime
            if not pd.api.types.is_datetime64_any_dtype(trades_df['time']):
                trades_df['time'] = pd.to_datetime(trades_df['time'])
        
        return trades_df, summary_dict
        
    except Exception as e:
        raise Exception(f"Error parsing {file_name}: {str(e)}")
        if os.path.exists(temp_file):
            os.remove(temp_file)